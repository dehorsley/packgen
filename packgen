#!/usr/bin/env python3
# This file covered by GPL 3 license
# C. David Horsley 2020
from pycparser import c_parser, c_ast, c_generator, parse_file


class LengthGenerator(c_ast.NodeVisitor):
    def __init__(self, filename):
        super().__init__()
        self.filename = filename

    def visit_Typedef(self, node):
        if node.coord.file != self.filename:
            return

        print("")
        print(f"const size_t len_{node.name} = 0", end="")

        for c in node.type.type.decls:
            self.visit(c)

        print(";")

    def visit_ArrayDecl(self, node):
        print("+", node.dim.value, "*(0")
        for c in node:
            self.visit(c)
        print(")")

    def visit_TypeDecl(self, node):
        type = node.type.names[-1]
        name = node.declname

        if type in {'uint8_t', 'int8_t', 'char'}:
            print("+1")

        elif type == 'uint16_t':
            print("+2")

        elif type == 'uint32_t':
            print("+4")

        elif type == 'uint64_t':
            print("+8")

        else:
            print(f"+len_{type}")


class UnmarshalGenerator(c_ast.NodeVisitor):
    endian = "little"

    def __init__(self, filename, endian=None):
        super().__init__()
        self.filename = filename
        self.array = False

        if endian:
            self.endian = endian

    def visit_Typedef(self, node):
        if node.coord.file != self.filename:
            return

        print("")
        print(
            f"ssize_t unmarshal_{node.name}({node.name} *t, uint8_t *data, size_t n)")
        print("{")
        print("ssize_t ret; uint8_t *p=data;")
        print(f"if (n < len_{node.name}) return -1;")

        for c in node.type.type.decls:
            self.visit(c)

        print("return (p-data);}")

    def visit_ArrayDecl(self, node):
        self.array = True
        print(f"for (int i=0; i < {node.dim.value}; i++)" "{")
        for c in node:
            self.visit(c)
        self.array = False
        print("}")

    def visit_TypeDecl(self, node):
        type = node.type.names[-1]
        name = node.declname
        if self.array:
            name += "[i]"

        if type in {'uint8_t', 'int8_t', 'char'}:
            self.gen_unmarshal_uint8(name)

        elif type == 'uint16_t':
            self.gen_unmarshal_uint16(name)

        elif type == 'uint32_t':
            self.gen_unmarshal_uint32(name)

        elif type == 'uint32_t':
            self.gen_unmarshal_uint32(name)

        else:
            print(f"ret = unmarshal_{type}(&t->{name}, p, n);")
            print("p += ret; n -= ret;")

    def gen_unmarshal_uint8(self, name):
        print(f"t->{name} = *p++; n--;")

    def gen_unmarshal_uint16(self, name):
        if self.endian == "little":
            print(f"t->{name} = (p[0]<<0) | (p[1]<<8); p+=2; n-=2;")
        else:
            print(f"t->{name} = (p[1]<<0) | (p[0]<<8); p+=2; n-=2;")

    def gen_unmarshal_uint32(self, name):
        if self.endian == "little":
            print(
                f"t->{name} = (p[0]<<0) | (p[1]<<8) | (p[2]<<16) | (p[3]<<24); p+=4; n-=4;")
        else:
            print(
                f"t->{name} = (p[3]<<0) | (p[2]<<8) | (p[1]<<16) | (p[0]<<24); p+=4; n-=4;")


INT_TYPES = {'uint8_t', 'int8_t', 'char', 'uint16_t',
             'int16_t', 'uint32_t', 'int32_t', 'uint64_t', 'int64_t'}

BOOL_TYPES = {'bool'}


class JsonMarshalGenerator(c_ast.NodeVisitor):
    def __init__(self, filename):
        super().__init__()
        self.filename = filename
        self.array = False

    def visit_Typedef(self, node):
        if node.coord.file != self.filename:
            return

        print("")
        print(
            f"json_t *marshal_json_{node.name}({node.name} *t)")
        print("{")
        print("json_t *root = json_object(); json_t *a; json_t *ret;")
        print("if (root == NULL) return NULL;")

        for c in node.type.type.decls:
            self.visit(c)

        print("return root;}")

    def visit_ArrayDecl(self, node):
        # handle strings as special case.
        if node.type.type.names[-1] == "char":
            print(
                f"ret = json_stringn(t->{node.type.declname}, {node.dim.value});")
            print("if (ret == NULL) return NULL;")
            print(f'json_object_set_new(root, "{node.type.declname}", ret);')
            return

        self.array = True
        print("")
        print("a = json_array();")
        print("if (a == NULL) return NULL;")
        print(f"for (int i=0; i < {node.dim.value}; i++)" "{")
        for c in node:
            self.visit(c)
        self.array = False
        print("}")
        print(f'json_object_set_new(root, "{node.type.declname}", a);')
        print("")

    def visit_TypeDecl(self, node):
        type = node.type.names[-1]
        name = node.declname
        if self.array:
            name += "[i]"

        if type in INT_TYPES:
            print(f"ret = json_integer(t->{name});")
        elif type in BOOL_TYPES:
            print(f"ret = json_boolean(t->{name});")
        else:
            print(f"ret = marshal_json_{type}(&t->{name});")

        print("if (ret == NULL) return NULL;")

        if self.array:
            print("json_array_append_new(a, ret);")
        else:
            print(f'json_object_set_new(root, "{name}", ret);')


if __name__ == "__main__":
    import sys
    import argparse
    from pathlib import Path
    parser = argparse.ArgumentParser(
        description='Generate unpacking routines for C struct')
    parser.add_argument('filename', metavar='filename',
                        help='the header file containing the typedefs')
    parser.add_argument('--little', dest='endian', action='store_const', const='little', default='big',
                        help='generate little endian pack/unpack routines (default big endian)')
    args = parser.parse_args()

    ast = parse_file(args.filename, use_cpp=True, cpp_path="gcc",
                     cpp_args=['-E', "-I%s" % (Path(__file__).resolve().parent / 'fake_libc_include')])

    print("#include <stdint.h>")
    print("#include <sys/types.h>")
    print("")
    print("#include <jansson.h>")
    print("")
    print(f'#include "{args.filename}"')
    print("")

    l = LengthGenerator(filename=args.filename)
    l.visit(ast)

    v = UnmarshalGenerator(filename=args.filename, endian=args.endian)
    v.visit(ast)

    v = JsonMarshalGenerator(filename=args.filename)
    v.visit(ast)
